{"version":3,"sources":["lib/Effects.ts","canvas/Canvas.tsx","canvas/AnimateFx.ts","canvas/animator/Colors.ts","canvas/animations/CanvasCountDown.ts","canvas/drawable/Drawable.ts","canvas/animator/SelectRandom.ts","canvas/drawable/Circle.ts","App.tsx","index.tsx"],"names":["getSize","el","width","offsetWidth","height","offsetHeight","Canvas","props","animator","ref","useRef","size","handlers","_useState","useState","current","_useState2","Object","slicedToArray","ComponentSize","setComponentSize","handleResize","useCallback","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","handler","value","err","return","debounceHandleResize","debounce","useLayoutEffect","window","addEventListener","removeEventListener","useComponentSize","onResize","_canvas","canvasRef","frameRef","canvas","setCanvas","requestAnimationFrame","doFrame","touchStart","touchMove","touchEnd","mouseLeft","mouseRight","cancelAnimationFrame","useAnimationFrame","react_default","a","createElement","className","COLORS","defaultOptions","freeze","color","lineWidth","callback","callbackInterval","countDownWithWrap","time","_options","options","assign","ctx","getContext","perimeterLength","offset","invocationInterval","invocationCount","rate","elapsed","reset","draw","delta","console","log","concat","beginPath","strokeStyle","moveTo","length","lineTo","stroke","DrawState","chance","require","frames","vanishLength","frameDelay","withVanishingState","drawable","vanishOptions","state","Normal","normalDraw","animationDuration","animationFrames","vanishable","getState","setState","Vanishing","imageData","count","imgs","pixelArr","data","slice","fill","imageDataArray","Array","from","e","i","p","Math","floor","weightedRandomDistrib","img","Image","tmpCanvas","document","tmpCtx","putImageData","ImageData","src","toDataURL","push","loadVanishFrames","step","alpha","clamp","globalAlpha","drawImage","position","x","y","min","max","peak","prob","seq","pow","abs","weighted","State","SelectRandom","_this","this","classCallCheck","lastFrame","activeTouches","colors","enableResetFlag","countDownToLock","countDownToSelect","selectedIndex","rect","getBoundingClientRect","left","top","lockPlayers","selectRandomPlayer","map","c","Selecting","unpickedTouches","filter","t","selectedId","random","id","index","findIndex","Finished","copyTouch","touch","identifier","pos","radius","fillStyle","arc","PI","sx","sy","getImageData","circle","pageX","pageY","updateTouches","touchEvent","Empty","Listening","touches","targetTouches","touchCount","clickAsTouch","mouseEvent","clientX","clientY","newTouch","toConsumableArray","clickToCancel","preventDefault","elapsedTime","fillRect","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","App","src_canvas_Canvas","ReactDOM","render","src_App_0","getElementById"],"mappings":"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","file":"static/js/main.8cd8ae1b.chunk.js","sourcesContent":["import { useState, useEffect, useRef, DOMElement, useCallback, useLayoutEffect } from \"react\";\r\nimport { debounce } from \"lodash\";\r\n\r\nfunction getSize(el: HTMLElement | any) {\r\n  if (!el) {\r\n    return {\r\n      width: 0,\r\n      height: 0\r\n    }\r\n  }\r\n\r\n  return {\r\n    width: el.offsetWidth,\r\n    height: el.offsetHeight\r\n  }\r\n}\r\n\r\n// https://github.com/rehooks/component-size/blob/master/index.js\r\nexport function useComponentSize<T>(ref: React.RefObject<T>, handlers?: (() => void)[]) {\r\n  let [ComponentSize, setComponentSize] = useState(\r\n    getSize(ref ? ref.current : {})\r\n  )\r\n\r\n  const handleResize = useCallback(\r\n    function handleResize() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n        if(handlers) {\r\n          for(let handler of handlers) {\r\n            handler();\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  const debounceHandleResize = debounce(handleResize, 300)\r\n\r\n  useLayoutEffect(\r\n    () => {\r\n      if (!ref.current) {\r\n        return\r\n      }\r\n      debounceHandleResize()\r\n      window.addEventListener('resize', debounceHandleResize)\r\n      return () => {\r\n        window.removeEventListener('resize', debounceHandleResize)\r\n      }\r\n    },\r\n    [ref.current]\r\n  )\r\n  return ComponentSize\r\n}\r\n\r\nexport function useWindowWidth() {\r\n  const [width, setWidth] = useState(window.innerWidth);\r\n  const elem = useRef(null);\r\n  useEffect(() => {\r\n    const handleResize = () => setWidth(window.innerWidth);\r\n    const debounceHandleResize = debounce(handleResize, 350);\r\n\r\n    window.addEventListener('resize', debounceHandleResize);\r\n    return () => {\r\n      window.removeEventListener('resize', debounceHandleResize);\r\n    };\r\n  });\r\n  \r\n  return width;\r\n}\r\n\r\nexport function useComponentTouch<T extends HTMLElement>(ref: React.RefObject<T>) {\r\n  let [ComponentSize, setComponentSize] = useState(\r\n    getSize(ref ? ref.current : {})\r\n  )\r\n\r\n  const onTouchStart = useCallback(\r\n    function onTouchStart() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  const onTouchMove = useCallback(\r\n    function onTouchMove() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  const onTouchEnd = useCallback(\r\n    function onTouchEnd() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  useLayoutEffect(\r\n    () => {\r\n      if (ref == null || !ref.current) {\r\n        return\r\n      }\r\n      \r\n      ref.current.addEventListener('touchstart', onTouchStart)\r\n      ref.current.addEventListener('touchmove', onTouchMove)\r\n      ref.current.addEventListener('touchend', onTouchEnd)\r\n      return () => {\r\n        const node = ref.current!;\r\n        node.removeEventListener('touchstart', onTouchStart)\r\n        node.removeEventListener('touchmove', onTouchMove)\r\n        node.removeEventListener('touchend', onTouchEnd)\r\n      }\r\n    },\r\n    [ref.current]\r\n  )\r\n  return ComponentSize\r\n}\r\n\r\nexport default useWindowWidth;","import React from 'react';\r\nimport { useWindowWidth, useComponentSize } from '../lib/Effects';\r\nimport { useRef } from 'react';\r\nimport { useAnimationFrame } from './AnimateFx';\r\nimport \"./Canvas.css\";\r\nimport IAnimationHandler from './animator/IAnimationHandler';\r\n\r\ninterface ICanvasProps {\r\n  width: number,\r\n  height: number,\r\n  animator: IAnimationHandler\r\n} \r\n\r\nconst Canvas: React.FC<ICanvasProps> = (props: ICanvasProps) => {\r\n  const animator = props.animator;\r\n  let ref = useRef<HTMLCanvasElement>(null)\r\n  let size = useComponentSize<HTMLElement>(ref, [animator.onResize])\r\n  let anim = useAnimationFrame(ref, animator)\r\n  // size == { width: 100, height: 200 }\r\n  let { width, height } = size\r\n  return (\r\n    <div className=\"Canvas\">\r\n      {width}\r\n      <canvas ref={ref} height={height} width={width}></canvas>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Canvas;","import { useRef, useLayoutEffect, RefObject } from \"react\";\r\nimport IAnimationHandler from \"./animator/IAnimationHandler\";\r\n\r\nexport function useAnimationFrame(_canvas: RefObject<HTMLCanvasElement>, animator: IAnimationHandler) {\r\n  const canvasRef = useRef(_canvas);\r\n\r\n  useLayoutEffect(\r\n    () => {\r\n      canvasRef.current = _canvas;\r\n    },\r\n    [_canvas]\r\n  )\r\n\r\n  const loop: FrameRequestCallback = (delta: number) => {\r\n    // const elapsed = delta - lastDelta;\r\n    // lastDelta = delta;\r\n    // console.log(elapsed);\r\n    // frameRef.current = requestAnimationFrame(\r\n    //   loop\r\n    // );\r\n    // const cb = callbackRef.current;\r\n    // const canvas = _canvas.current;\r\n    // const ctx = canvas != null ? canvas.getContext('2d') : null; \r\n    // if(canvas != null && ctx != null) {\r\n    //   cb(canvas, ctx);\r\n    // }\r\n  };\r\n\r\n  const frameRef = useRef<number>();\r\n  useLayoutEffect(() => {\r\n    const canvas = _canvas.current;\r\n    if(canvas != null) {\r\n      animator.setCanvas(canvas)\r\n      frameRef.current = requestAnimationFrame(\r\n        animator.doFrame\r\n      );\r\n      \r\n      canvas.addEventListener('touchstart', animator.touchStart);\r\n      canvas.addEventListener('touchmove', animator.touchMove);\r\n      canvas.addEventListener('touchend', animator.touchEnd);\r\n      canvas.addEventListener('click', animator.mouseLeft);\r\n      canvas.addEventListener('contextmenu', animator.mouseRight);\r\n      \r\n      return () => {\r\n        cancelAnimationFrame(frameRef.current!);\r\n\r\n        canvas.removeEventListener('touchstart', animator.touchStart);\r\n        canvas.removeEventListener('touchmove', animator.touchMove);\r\n        canvas.removeEventListener('touchend', animator.touchEnd);\r\n        canvas.removeEventListener('click', animator.mouseLeft);\r\n        canvas.removeEventListener('contextmenu', animator.mouseRight);\r\n      }\r\n    }\r\n  }, []);\r\n};","export const COLORS = [\r\n  \"#C0C0C0\", // silver\r\n  \"#FF0000\", // red\r\n  \"#800000\", // maroon\r\n  \"#FFFF00\", // yellow\r\n  \"#808000\", // olive\r\n  \"#00FF00\", // lime\r\n  \"#008000\", // green\r\n  \"#00FFFF\", // aqua\r\n  \"#008080\", // teal\r\n  \"#0000FF\", // blue\r\n  \"#000080\", // navy\r\n  \"#FF00FF\", // fuschia\r\n  \"#800080\", // purple\\\r\n]","\r\nexport interface ICountDownOptions {\r\n  color?: string,\r\n  lineWidth?: number,\r\n  callback?: (() => void),\r\n  callbackInterval?: number\r\n}\r\n\r\nconst defaultOptions = Object.freeze({\r\n  color: \"black\",\r\n  lineWidth: 5,\r\n  callback: () => {},\r\n  callbackInterval: 1\r\n})\r\n\r\n\r\nexport function countDownWithWrap(canvas: HTMLCanvasElement, time: number, _options: ICountDownOptions): any {\r\n  const options = Object.assign({}, defaultOptions, _options)\r\n  const lineWidth = options.lineWidth\r\n  const color = options.color\r\n  const callback = options.callback\r\n  const ctx = canvas.getContext(\"2d\")!\r\n  const width = canvas.width - lineWidth\r\n  const height = canvas.height - lineWidth\r\n  const perimeterLength = 2 * (width + height)\r\n  const offset = lineWidth / 2\r\n  const invocationInterval = time / options.callbackInterval\r\n  let invocationCount = 0\r\n\r\n  const rate = perimeterLength / time\r\n  let elapsed = 0\r\n\r\n  return ({\r\n    reset() {\r\n      elapsed = 0\r\n      invocationCount = 0\r\n      return\r\n    },\r\n\r\n    draw(delta: number) {\r\n      elapsed += delta\r\n      if(elapsed > time) {\r\n        elapsed = time\r\n      }\r\n      if(elapsed >= (invocationCount + 1) * invocationInterval) {\r\n        console.log(`invocation ${invocationCount}`)\r\n        callback()\r\n        invocationCount++\r\n      }\r\n      ctx.beginPath()\r\n      ctx.lineWidth = lineWidth\r\n      ctx.strokeStyle = color\r\n      ctx.moveTo(offset, offset)\r\n\r\n      let length = rate * elapsed\r\n      if(length <= width) {\r\n        ctx.lineTo(length + offset, offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(width + offset, offset)\r\n      length -= width\r\n      if(length <= height) {\r\n        ctx.lineTo(width + offset, length + offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(width + offset, height + offset)\r\n      length -= height\r\n      if(length <= width) {\r\n        ctx.lineTo(width - length + offset, height + offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(offset, height + offset)\r\n      length -= width\r\n      if(length <= height) {\r\n        ctx.lineTo(offset, height - length + offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(offset, offset)\r\n      ctx.stroke()\r\n    }\r\n  });\r\n}","var chance: Chance.Chance = require('chance')();\r\n\r\nexport interface iPoint {\r\n  x: number,\r\n  y: number\r\n}\r\n\r\nexport enum DrawState {\r\n  Normal,\r\n  Vanishing\r\n}\r\n\r\nexport interface iDrawable {\r\n  draw: (ctx: CanvasRenderingContext2D, delta: number) => void\r\n  id?: number\r\n  position: iPoint\r\n  color: string\r\n  imageData?: ImageData\r\n}\r\n\r\nexport interface iRect extends iDrawable {\r\n  width: number\r\n  length: number\r\n}\r\n\r\nexport interface iCircle extends iDrawable {\r\n  radius: number\r\n}\r\n\r\nexport interface withVanishingState extends iDrawable {\r\n  getState: () => DrawState\r\n  setState: (value: DrawState) => void\r\n}\r\n\r\nexport interface iVanishingOptions {\r\n  frames?: number\r\n  vanishLength?: number\r\n  frameDelay?: number\r\n}\r\n\r\nexport interface iVanishingSettings {\r\n  frames: number\r\n  vanishLength: number\r\n  frameDelay: number\r\n}\r\n\r\nconst defaultOptions: iVanishingSettings = {\r\n  frames: 45,\r\n  vanishLength: 2500,\r\n  frameDelay: 100\r\n}\r\n\r\nexport function withVanishingState<T extends iDrawable>(drawable: T, ctx: CanvasRenderingContext2D, options: iVanishingOptions | undefined): T & withVanishingState {\r\n  const vanishOptions = Object.assign({}, defaultOptions, options)\r\n  let state: DrawState = DrawState.Normal\r\n  let normalDraw = drawable.draw\r\n  let animationDuration = 0\r\n  let animationFrames: HTMLImageElement[] = []\r\n  let vanishable = {\r\n    vanishOptions,\r\n    getState() { return state },\r\n    setState(value: DrawState) {\r\n      if(state == value) {\r\n        return;\r\n      }\r\n      state = value\r\n      if(state == DrawState.Normal) {\r\n        animationDuration = 0\r\n      } else if(state == DrawState.Vanishing) {\r\n        animationDuration = 0\r\n        if(animationFrames.length == 0) {\r\n          const sx = drawable.imageData\r\n          animationFrames = loadVanishFrames(drawable.imageData!, vanishOptions.frames)\r\n          let x = 2\r\n        }\r\n      }\r\n    },\r\n    draw: function(ctx: CanvasRenderingContext2D, delta: number) {\r\n      if(state == DrawState.Normal) {\r\n        normalDraw(ctx, delta)\r\n      } else if(state == DrawState.Vanishing) {\r\n        animationDuration += delta\r\n        if(animationDuration >= (animationFrames.length * vanishOptions.frameDelay) + vanishOptions.vanishLength) {\r\n          return\r\n        }\r\n\r\n        for(let i = 0; i < animationFrames.length; i++) {\r\n          const step = animationDuration - (i+1) * vanishOptions.frameDelay\r\n          let alpha = clamp(1 - (step / vanishOptions.vanishLength), 0, 1)\r\n          ctx.globalAlpha = alpha\r\n          ctx.drawImage(animationFrames[i], drawable.position.x, drawable.position.y)\r\n        }\r\n        ctx.globalAlpha = 1;\r\n      }\r\n    } \r\n  }\r\n\r\n  return Object.assign({}, drawable, vanishable)\r\n}\r\n\r\nconst clamp = (value: number, min: number, max: number) => {\r\n  if(value < min) {\r\n    return min\r\n  } else if (value > max) {\r\n    return max\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nconst weightedRandomDistrib = (peak: number, count: number) => {\r\n  const prob = [], seq = [];\r\n  for(let i=0;i<count;i++) {\r\n    prob.push(Math.pow(count-Math.abs(peak-i), count/2));\r\n    seq.push(i);\r\n  }\r\n  return chance.weighted(seq, prob);\r\n}\r\n\r\nfunction loadVanishFrames (imageData: ImageData, count: number): HTMLImageElement[] {\r\n  let imgs: HTMLImageElement[] = [];\r\n  const pixelArr = imageData.data;\r\n  const data = imageData.data.slice(0).fill(0);\r\n  const width = imageData.width\r\n  const height = imageData.height\r\n  let imageDataArray = Array.from({length: count}, e => data.slice(0));\r\n\r\n  //put pixel info to imageDataArray (Weighted Distributed)\r\n  for (let i = 0; i < pixelArr.length; i+=4) {\r\n    //find the highest probability canvas the pixel should be in\r\n    const p = Math.floor((i/pixelArr.length) * count);\r\n    const a = imageDataArray[weightedRandomDistrib(p, count)];\r\n    \r\n    // assign RGBA values from image to dust canvas\r\n    a[i] = pixelArr[i];\r\n    a[i+1] = pixelArr[i+1];\r\n    a[i+2] = pixelArr[i+2];\r\n    a[i+3] = pixelArr[i+3];\r\n    if(a[i] == 255 && a[i+1] == 255 && a[i+2] == 255) {\r\n      a[i+3] = 0;\r\n    }\r\n  }\r\n  for(let i = 0; i < imageDataArray.length; i++) {\r\n    let img = new Image();\r\n    let tmpCanvas = document.createElement(\"canvas\");\r\n    tmpCanvas.width = width;\r\n    tmpCanvas.height = height;\r\n    let tmpCtx = tmpCanvas.getContext(\"2d\")!;\r\n    tmpCtx.putImageData(new ImageData(imageDataArray[i], width, height), 0, 0);\r\n    img.src = tmpCanvas.toDataURL('image/png');\t\r\n    imgs.push(img);\r\n  }\r\n  return imgs;\r\n}","import IAnimationHandler from './IAnimationHandler';\r\nimport { COLORS } from './Colors';\r\nimport { countDownWithWrap } from '../animations/CanvasCountDown';\r\nimport { iCircle, withVanishingState, DrawState } from '../drawable/Drawable';\r\nimport circle from '../drawable/Circle';\r\nimport { timingSafeEqual } from 'crypto';\r\n\r\ninterface ITouch {\r\n  id: number\r\n  color: string\r\n  position: IPoint\r\n}\r\n\r\ninterface IPoint {\r\n  x: number\r\n  y: number\r\n}\r\n\r\n//configuration\r\nconst circleRadius = 60\r\nconst backgroundColor = 'black'\r\n\r\nenum State {\r\n  Empty, \r\n  Listening,\r\n  Selecting,\r\n  Finished\r\n}\r\n\r\ninterface iSimulatedTouch {\r\n  identifier: number\r\n  pageX: number\r\n  pageY: number\r\n}\r\n\r\nclass SelectRandom implements IAnimationHandler {\r\n  touchStart: (te: TouchEvent) => void\r\n  touchMove: (te: TouchEvent) => void\r\n  touchEnd: (te: TouchEvent) => void\r\n  mouseLeft: (me: MouseEvent) => void\r\n  mouseRight: (me: MouseEvent) => void\r\n\r\n  lastFrame: number\r\n  canvas: HTMLCanvasElement | null\r\n  ctx: CanvasRenderingContext2D | null\r\n  width: number\r\n  height: number\r\n\r\n  activeTouches: (iCircle | (withVanishingState & iCircle))[]\r\n  colors: string[]\r\n  offset: IPoint\r\n  state: State\r\n  enableResetFlag: boolean\r\n\r\n  countDownToLock: any\r\n  countDownToSelect: any\r\n  selectedIndex: number\r\n\r\n  constructor() {\r\n    this.lastFrame = 0\r\n    this.touchStart = this.updateTouches\r\n    this.touchMove = this.updateTouches\r\n    this.touchEnd = this.updateTouches\r\n    this.mouseLeft = this.clickAsTouch\r\n    this.mouseRight = this.clickToCancel\r\n\r\n    this.canvas = null\r\n    this.ctx = null\r\n    this.countDownToLock = null\r\n    this.selectedIndex = -1\r\n\r\n    this.activeTouches = []\r\n    this.colors = [...COLORS]\r\n    this.offset = { x: 0, y: 0 }\r\n    this.height = this.width = 0\r\n    this.state = State.Empty\r\n    this.enableResetFlag = false\r\n  }\r\n\r\n  setCanvas = (_canvas: HTMLCanvasElement) => {\r\n    this.canvas = _canvas\r\n    this.ctx = this.canvas.getContext('2d')!\r\n    this.onResize()\r\n  }\r\n\r\n  onResize = () => {\r\n    const rect = this.canvas!.getBoundingClientRect()\r\n    this.offset = { x: rect.left, y: rect.top }\r\n    const canvas = this.canvas!\r\n    this.width = canvas.width\r\n    this.height = canvas.height\r\n    this.countDownToLock = countDownWithWrap(canvas, 2000, { color: \"red\", callback: this.lockPlayers, lineWidth: 10 })\r\n    \r\n  }\r\n\r\n  lockPlayers = () => {\r\n    this.countDownToSelect = countDownWithWrap(this.canvas!, 4000, { color: \"yellow\", callback: this.selectRandomPlayer, callbackInterval: this.activeTouches.length - 1, lineWidth: 10 })\r\n    this.activeTouches = this.activeTouches.map(c => withVanishingState(c, this.ctx!, undefined));\r\n    this.state = State.Selecting\r\n  }\r\n\r\n  selectRandomPlayer = () => {\r\n    const unpickedTouches = (this.activeTouches as (iCircle & withVanishingState)[]).filter(t => t.getState() === DrawState.Normal)\r\n\r\n    const selectedId = unpickedTouches[Math.floor(Math.random() * unpickedTouches.length)].id\r\n    const index = this.activeTouches.findIndex(t => t.id == selectedId)\r\n    let target = this.activeTouches[index] as iCircle & withVanishingState\r\n    target.setState(DrawState.Vanishing)\r\n    if(unpickedTouches.length == 2) {\r\n      this.state = State.Finished\r\n    }\r\n  }\r\n\r\n  copyTouch = (touch: Touch | iSimulatedTouch): iCircle => {\r\n    const id = touch.identifier\r\n    return circle(id, COLORS[id], { x: touch.pageX - this.offset.x, y: touch.pageY - this.offset.y }, circleRadius)\r\n  }\r\n\r\n  updateTouches = (touchEvent: TouchEvent) => {\r\n    if(this.state == State.Empty || this.state == State.Listening) {\r\n      const touches = Array.from(touchEvent.targetTouches)\r\n      if(touches.length != this.activeTouches.length) {\r\n        this.countDownToLock.reset()\r\n      }\r\n      this.activeTouches = touches.map(t => this.copyTouch(t))\r\n      const touchCount = this.activeTouches.length\r\n      if(touchCount <= 1) {\r\n        this.state = State.Empty\r\n      }\r\n      if(touchCount > 1) {\r\n        this.state = State.Listening\r\n      }\r\n    }\r\n    if(this.state == State.Finished) {\r\n      if(touchEvent.targetTouches.length > 0 && this.enableResetFlag) {\r\n        this.state = State.Empty\r\n        this.enableResetFlag = false\r\n      }\r\n      if(touchEvent.targetTouches.length == 0) {\r\n        this.enableResetFlag = true\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  clickAsTouch = (mouseEvent: MouseEvent) => {\r\n    if(this.state == State.Empty || this.state == State.Listening) {\r\n      const identifier = this.activeTouches.length;\r\n      const touch: iSimulatedTouch = { \r\n        identifier,\r\n        pageX: mouseEvent.clientX,\r\n        pageY: mouseEvent.clientY\r\n      }\r\n\r\n      const newTouch = this.copyTouch(touch);\r\n      this.activeTouches = [...this.activeTouches, newTouch]\r\n\r\n      if(this.activeTouches.length > 1 && this.state == State.Empty) {\r\n        this.state = State.Listening\r\n      }\r\n      this.countDownToLock.reset();\r\n    }\r\n\r\n    if(this.state == State.Finished) {\r\n      this.activeTouches = []\r\n      this.state = State.Empty\r\n    }\r\n  }\r\n\r\n  clickToCancel = (mouseEvent: MouseEvent) => {\r\n    mouseEvent.preventDefault();\r\n    if(this.activeTouches.length == 0 || this.state == State.Selecting) {\r\n      return\r\n    }\r\n\r\n    if(this.state == State.Finished) {\r\n      this.activeTouches = []\r\n      this.state = State.Empty\r\n      return\r\n    }\r\n\r\n    this.activeTouches = this.activeTouches.slice(0, -1);\r\n    if(this.activeTouches.length <= 1) {\r\n      this.state = State.Empty\r\n    }\r\n    this.countDownToLock.reset();\r\n  }\r\n\r\n  doFrame = (elapsedTime: number) => {\r\n    const delta = elapsedTime - this.lastFrame\r\n    this.lastFrame = elapsedTime\r\n    window.requestAnimationFrame(this.doFrame)\r\n    \r\n    if(this.ctx == null || this.ctx == undefined) {\r\n      return\r\n    }\r\n    \r\n    const ctx = this.ctx\r\n    ctx.fillStyle = backgroundColor\r\n    ctx.fillRect(0,0, this.width, this.height)\r\n\r\n    if(this.state == State.Empty) {\r\n      this.countDownToLock.reset()\r\n    }\r\n\r\n    if(this.state != State.Finished)\r\n    {\r\n      for(let touch of this.activeTouches) {\r\n        touch.draw(ctx, delta)\r\n      }\r\n    }\r\n\r\n    if(this.state == State.Listening) {\r\n      this.countDownToLock.draw(delta)\r\n    }\r\n\r\n    if(this.state == State.Selecting) {\r\n      this.countDownToSelect.draw(delta);\r\n    }\r\n\r\n    if(this.state == State.Finished) {\r\n      for(let touch of this.activeTouches) {\r\n        touch.draw(ctx, delta)\r\n        // ctx.beginPath()\r\n        // ctx.fillStyle = touch.color\r\n        // ctx.arc(touch.position.x, touch.position.y, circleRadius, 0, Math.PI * 2)\r\n        // ctx.fill()\r\n      }\r\n    }\r\n  }\r\n\r\n  // testRender = () => {\r\n  //   this.activeTouches = [{\r\n  //     id: 0,\r\n  //     position: {\r\n  //       x: 50,\r\n  //       y: 50\r\n  //     },\r\n  //     color: this.colors[0]\r\n  //   }, {\r\n  //     id: 1,\r\n  //     position: {\r\n  //       x: 100,\r\n  //       y: 50\r\n  //     },\r\n  //     color: this.colors[1]\r\n  //   }]\r\n  // }\r\n}\r\n\r\nexport default SelectRandom;","import { iCircle, iPoint } from \"./Drawable\";\r\n\r\nexport default function circle(id: number, color: string, pos: iPoint, radius: number): iCircle {\r\n  let imageData: (ImageData | undefined)\r\n  let position = pos\r\n  return ({\r\n    get id() { return id },\r\n    get imageData() { return imageData },\r\n    get position() { return position },\r\n    set position(value) { position = value },\r\n    get radius() { return radius },\r\n    set radius(value) { radius = value },\r\n    get color() { return color },\r\n    set color(value) { color = value },\r\n    draw: (ctx, delta) => {\r\n      ctx.beginPath()\r\n      ctx.fillStyle = color\r\n      ctx.arc(position.x, position.y, radius, 0, Math.PI * 2)\r\n      ctx.fill()\r\n      if(imageData == undefined) {\r\n        const sx = position.x - radius\r\n        const sy = position.y - radius\r\n        imageData = ctx.getImageData(sx, sy, radius * 2, radius * 2)\r\n        let t = 2\r\n      }\r\n    }\r\n  })\r\n}","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Canvas from './canvas/Canvas';\nimport SelectRandom from './canvas/animator/SelectRandom';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n        <p>Testing</p>\n      <Canvas height={400} width={600} animator={ new SelectRandom() } />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}