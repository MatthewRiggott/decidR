{"version":3,"sources":["lib/Effects.ts","canvas/Canvas.tsx","canvas/AnimateFx.ts","canvas/animator/Colors.ts","canvas/animations/CanvasCountDown.ts","canvas/drawable/Drawable.ts","canvas/animator/SelectRandom.ts","canvas/drawable/Circle.ts","App.tsx","index.tsx"],"names":["getSize","el","width","offsetWidth","height","offsetHeight","Canvas","props","animator","ref","useRef","size","handlers","_useState","useState","current","_useState2","Object","slicedToArray","ComponentSize","setComponentSize","handleResize","useCallback","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","handler","value","err","return","debounceHandleResize","debounce","useLayoutEffect","window","addEventListener","removeEventListener","useComponentSize","onResize","_canvas","canvasRef","frameRef","canvas","setCanvas","requestAnimationFrame","doFrame","touchStart","touchMove","touchEnd","mouseLeft","mouseRight","cancelAnimationFrame","useAnimationFrame","react_default","a","createElement","className","COLORS","defaultOptions","freeze","color","lineWidth","callback","callbackInterval","countDownWithWrap","time","_options","options","assign","ctx","getContext","perimeterLength","offset","invocationInterval","invocationCount","rate","elapsed","reset","draw","delta","console","log","concat","beginPath","strokeStyle","moveTo","length","lineTo","stroke","DrawState","DrawMode","chance","require","frames","vanishLength","frameDelay","weightedRandomDistrib","peak","count","prob","seq","i","push","Math","pow","abs","weighted","loadVanishFrames","imageData","colorFilter","imgs","pixelArr","data","slice","fill","imageDataArray","Array","from","e","p","floor","hexToRGB","red","green","blue","img","Image","tmpCanvas","document","putImageData","ImageData","src","toDataURL","hexString","hexColorNumber","parseInt","replace","State","SelectionMode","circleRadius","backgroundColor","SelectRandom","_this","this","mode","arguments","Teams","classCallCheck","lastFrame","activeTouches","colors","_state","enableResetFlag","selectionMode","teamCount","countDownToLock","countDownToSelect","selectedIndex","rect","getBoundingClientRect","x","left","y","top","lockPlayers","touches","callbacks","FirstOnly","clamp","selectRandomPlayer","vanishOptions","range","shuffle","keys","teams","teamMap","id","map","t","nextColor","drawable","state","Normal","normalDraw","animationDuration","Vanishing","animationFrames","vanishable","getMode","setMode","setState","Animating","getState","AnimationFinished","loadImageData","reloadFrames","Unvanishing","dx","position","dy","radius","step","alpha","globalAlpha","drawImage","withVanishingState","Selecting","unpickedTouches","filter","selectedId","random","index","findIndex","threshold","Finished","copyTouch","touch","identifier","pos","context","fillStyle","fillRect","arc","PI","getImageData","circle","pageX","pageY","updateTouches","touchEvent","Empty","Listening","targetTouches","touchCount","clickAsTouch","mouseEvent","clientX","clientY","newTouch","toConsumableArray","clickToCancel","preventDefault","elapsedTime","Initializing","App","src_canvas_Canvas","ReactDOM","render","src_App_0","getElementById"],"mappings":"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","file":"static/js/main.4af2ce08.chunk.js","sourcesContent":["import { useState, useEffect, useRef, DOMElement, useCallback, useLayoutEffect } from \"react\";\r\nimport { debounce } from \"lodash\";\r\n\r\nfunction getSize(el: HTMLElement | any) {\r\n  if (!el) {\r\n    return {\r\n      width: 0,\r\n      height: 0\r\n    }\r\n  }\r\n\r\n  return {\r\n    width: el.offsetWidth,\r\n    height: el.offsetHeight\r\n  }\r\n}\r\n\r\n// https://github.com/rehooks/component-size/blob/master/index.js\r\nexport function useComponentSize<T>(ref: React.RefObject<T>, handlers?: (() => void)[]) {\r\n  let [ComponentSize, setComponentSize] = useState(\r\n    getSize(ref ? ref.current : {})\r\n  )\r\n\r\n  const handleResize = useCallback(\r\n    function handleResize() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n        if(handlers) {\r\n          for(let handler of handlers) {\r\n            handler();\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  const debounceHandleResize = debounce(handleResize, 300)\r\n\r\n  useLayoutEffect(\r\n    () => {\r\n      if (!ref.current) {\r\n        return\r\n      }\r\n      debounceHandleResize()\r\n      window.addEventListener('resize', debounceHandleResize)\r\n      return () => {\r\n        window.removeEventListener('resize', debounceHandleResize)\r\n      }\r\n    },\r\n    [ref.current]\r\n  )\r\n  return ComponentSize\r\n}\r\n\r\nexport function useWindowWidth() {\r\n  const [width, setWidth] = useState(window.innerWidth);\r\n  const elem = useRef(null);\r\n  useEffect(() => {\r\n    const handleResize = () => setWidth(window.innerWidth);\r\n    const debounceHandleResize = debounce(handleResize, 350);\r\n\r\n    window.addEventListener('resize', debounceHandleResize);\r\n    return () => {\r\n      window.removeEventListener('resize', debounceHandleResize);\r\n    };\r\n  });\r\n  \r\n  return width;\r\n}\r\n\r\nexport function useComponentTouch<T extends HTMLElement>(ref: React.RefObject<T>) {\r\n  let [ComponentSize, setComponentSize] = useState(\r\n    getSize(ref ? ref.current : {})\r\n  )\r\n\r\n  const onTouchStart = useCallback(\r\n    function onTouchStart() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  const onTouchMove = useCallback(\r\n    function onTouchMove() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  const onTouchEnd = useCallback(\r\n    function onTouchEnd() {\r\n      if (ref.current) {\r\n        setComponentSize(getSize(ref.current))\r\n      }\r\n    },\r\n    [ref]\r\n  )\r\n\r\n  useLayoutEffect(\r\n    () => {\r\n      if (ref == null || !ref.current) {\r\n        return\r\n      }\r\n      \r\n      ref.current.addEventListener('touchstart', onTouchStart)\r\n      ref.current.addEventListener('touchmove', onTouchMove)\r\n      ref.current.addEventListener('touchend', onTouchEnd)\r\n      return () => {\r\n        const node = ref.current!;\r\n        node.removeEventListener('touchstart', onTouchStart)\r\n        node.removeEventListener('touchmove', onTouchMove)\r\n        node.removeEventListener('touchend', onTouchEnd)\r\n      }\r\n    },\r\n    [ref.current]\r\n  )\r\n  return ComponentSize\r\n}\r\n\r\nexport default useWindowWidth;","import React from 'react';\r\nimport { useWindowWidth, useComponentSize } from '../lib/Effects';\r\nimport { useRef } from 'react';\r\nimport { useAnimationFrame } from './AnimateFx';\r\nimport \"./Canvas.css\";\r\nimport IAnimationHandler from './animator/IAnimationHandler';\r\n\r\ninterface ICanvasProps {\r\n  width: number,\r\n  height: number,\r\n  animator: IAnimationHandler\r\n} \r\n\r\nconst Canvas: React.FC<ICanvasProps> = (props: ICanvasProps) => {\r\n  const animator = props.animator;\r\n  let ref = useRef<HTMLCanvasElement>(null)\r\n  let size = useComponentSize<HTMLElement>(ref, [animator.onResize])\r\n  let anim = useAnimationFrame(ref, animator)\r\n  // size == { width: 100, height: 200 }\r\n  let { width, height } = size\r\n  return (\r\n    <div className=\"Canvas\">\r\n      <canvas ref={ref} height={height} width={width}></canvas>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Canvas;","import { useRef, useLayoutEffect, RefObject } from \"react\";\r\nimport IAnimationHandler from \"./animator/IAnimationHandler\";\r\n\r\nexport function useAnimationFrame(_canvas: RefObject<HTMLCanvasElement>, animator: IAnimationHandler) {\r\n  const canvasRef = useRef(_canvas);\r\n\r\n  useLayoutEffect(\r\n    () => {\r\n      canvasRef.current = _canvas;\r\n    },\r\n    [_canvas]\r\n  )\r\n\r\n  const loop: FrameRequestCallback = (delta: number) => {\r\n    // const elapsed = delta - lastDelta;\r\n    // lastDelta = delta;\r\n    // console.log(elapsed);\r\n    // frameRef.current = requestAnimationFrame(\r\n    //   loop\r\n    // );\r\n    // const cb = callbackRef.current;\r\n    // const canvas = _canvas.current;\r\n    // const ctx = canvas != null ? canvas.getContext('2d') : null; \r\n    // if(canvas != null && ctx != null) {\r\n    //   cb(canvas, ctx);\r\n    // }\r\n  };\r\n\r\n  const frameRef = useRef<number>();\r\n  useLayoutEffect(() => {\r\n    const canvas = _canvas.current;\r\n    if(canvas != null) {\r\n      animator.setCanvas(canvas)\r\n      frameRef.current = requestAnimationFrame(\r\n        animator.doFrame\r\n      );\r\n      \r\n      canvas.addEventListener('touchstart', animator.touchStart);\r\n      canvas.addEventListener('touchmove', animator.touchMove);\r\n      canvas.addEventListener('touchend', animator.touchEnd);\r\n      canvas.addEventListener('click', animator.mouseLeft);\r\n      canvas.addEventListener('contextmenu', animator.mouseRight);\r\n      \r\n      return () => {\r\n        cancelAnimationFrame(frameRef.current!);\r\n\r\n        canvas.removeEventListener('touchstart', animator.touchStart);\r\n        canvas.removeEventListener('touchmove', animator.touchMove);\r\n        canvas.removeEventListener('touchend', animator.touchEnd);\r\n        canvas.removeEventListener('click', animator.mouseLeft);\r\n        canvas.removeEventListener('contextmenu', animator.mouseRight);\r\n      }\r\n    }\r\n  }, []);\r\n};","export const COLORS = [\r\n  \"#ffffff\", // white\r\n  \"#c0c0c0\", // silver\r\n  \"#FF0000\", // red\r\n  \"#800000\", // maroon\r\n  \"#FFFF00\", // yellow\r\n  \"#00FF00\", // lime\r\n  \"#008000\", // green\r\n  \"#7fffd4\", // aquamarine\r\n  \"#008080\", // teal\r\n  \"#1e90ff\", // blue\r\n  \"#000080\", // navy\r\n  \"#FF00FF\", // fuschia\r\n  \"#663399\", // purple\r\n  \"#ffa500\", // orange\r\n  \"#ff69b4\" // pink\r\n]","\r\nexport interface ICountDownOptions {\r\n  color?: string,\r\n  lineWidth?: number,\r\n  callback?: (() => void),\r\n  callbackInterval?: number\r\n}\r\n\r\nconst defaultOptions = Object.freeze({\r\n  color: \"black\",\r\n  lineWidth: 5,\r\n  callback: () => {},\r\n  callbackInterval: 1\r\n})\r\n\r\n\r\nexport function countDownWithWrap(canvas: HTMLCanvasElement, time: number, _options: ICountDownOptions): any {\r\n  const options = Object.assign({}, defaultOptions, _options)\r\n  const lineWidth = options.lineWidth\r\n  const color = options.color\r\n  const callback = options.callback\r\n  const ctx = canvas.getContext(\"2d\")!\r\n  const width = canvas.width - lineWidth\r\n  const height = canvas.height - lineWidth\r\n  const perimeterLength = 2 * (width + height)\r\n  const offset = lineWidth / 2\r\n  const invocationInterval = time / options.callbackInterval\r\n  let invocationCount = 0\r\n\r\n  const rate = perimeterLength / time\r\n  let elapsed = 0\r\n\r\n  return ({\r\n    reset() {\r\n      elapsed = 0\r\n      invocationCount = 0\r\n      return\r\n    },\r\n\r\n    draw(delta: number) {\r\n      elapsed += delta\r\n      if(elapsed > time) {\r\n        elapsed = time\r\n      }\r\n      if(elapsed >= (invocationCount + 1) * invocationInterval) {\r\n        console.log(`invocation ${invocationCount}`)\r\n        callback()\r\n        invocationCount++\r\n      }\r\n      ctx.beginPath()\r\n      ctx.lineWidth = lineWidth\r\n      ctx.strokeStyle = color\r\n      ctx.moveTo(offset, offset)\r\n\r\n      let length = rate * elapsed\r\n      if(length <= width) {\r\n        ctx.lineTo(length + offset, offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(width + offset, offset)\r\n      length -= width\r\n      if(length <= height) {\r\n        ctx.lineTo(width + offset, length + offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(width + offset, height + offset)\r\n      length -= height\r\n      if(length <= width) {\r\n        ctx.lineTo(width - length + offset, height + offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(offset, height + offset)\r\n      length -= width\r\n      if(length <= height) {\r\n        ctx.lineTo(offset, height - length + offset)\r\n        ctx.stroke()\r\n        return\r\n      }\r\n      ctx.lineTo(offset, offset)\r\n      ctx.stroke()\r\n    }\r\n  });\r\n}","import { clamp } from \"lodash\";\r\nimport { Color } from \"csstype\";\r\nimport { isCircle } from \"./Circle\";\r\nimport { callbackify } from \"util\";\r\n\r\nvar chance: Chance.Chance = require('chance')();\r\n\r\nexport interface iPoint {\r\n  x: number,\r\n  y: number\r\n}\r\n\r\nexport enum DrawState {\r\n  Normal,\r\n  Animating,\r\n  AnimationFinished\r\n}\r\n\r\nexport enum DrawMode {\r\n  Vanishing,\r\n  Unvanishing\r\n}\r\n\r\nexport interface iDrawable {\r\n  draw: (ctx: CanvasRenderingContext2D, delta: number) => void\r\n  loadImageData: () => void\r\n  id?: number\r\n  position: iPoint\r\n  color: string\r\n  imageData?: ImageData\r\n}\r\n\r\nexport interface iRect extends iDrawable {\r\n  width: number\r\n  length: number\r\n}\r\n\r\nexport interface iCircle extends iDrawable {\r\n  radius: number\r\n}\r\n\r\nexport interface withVanishingState extends iDrawable {\r\n  getMode: () => DrawMode\r\n  setMode: (value: DrawMode) => void\r\n  getState: () => DrawState\r\n  setState: (value: DrawState) => void\r\n  reloadFrames: () => void\r\n}\r\n\r\nexport function isVanishable(object: any): object is withVanishingState {\r\n  return true\r\n  //return 'getMode' in object && 'getState' in object;\r\n}\r\n\r\n\r\nexport interface iVanishingOptions {\r\n  frames?: number\r\n  vanishLength?: number\r\n  frameDelay?: number\r\n  callback?: boolean\r\n  nextColor?: Color\r\n}\r\n\r\nexport interface iVanishingSettings {\r\n  frames: number\r\n  vanishLength: number\r\n  frameDelay: number\r\n}\r\n\r\nconst defaultOptions: iVanishingSettings = {\r\n  frames: 45,\r\n  vanishLength: 2500,\r\n  frameDelay: 100,\r\n}\r\n\r\nexport function withVanishingState<T extends iDrawable>(drawable: T, ctx: CanvasRenderingContext2D, options?: iVanishingOptions): T & withVanishingState {\r\n  const vanishOptions = Object.assign({}, defaultOptions, options)\r\n  let state: DrawState = DrawState.Normal\r\n  let normalDraw = drawable.draw\r\n  let animationDuration = 0\r\n  let mode = DrawMode.Vanishing\r\n  let animationFrames: HTMLImageElement[] = []\r\n  let vanishable = {\r\n    vanishOptions,\r\n    getMode() { return mode },\r\n    setMode(value: DrawMode) {\r\n      mode = value\r\n      animationDuration = 0\r\n      this.setState(DrawState.Animating)\r\n    },\r\n    getState() { return state },\r\n    setState(value: DrawState) {\r\n      if(state == value) {\r\n        return;\r\n      }\r\n      state = value\r\n      if(state == DrawState.Normal) {\r\n        animationDuration = 0\r\n      } else if(state == DrawState.Animating) {\r\n        animationDuration = 0\r\n        if(animationFrames.length == 0) {\r\n          const sx = drawable.imageData\r\n          animationFrames = loadVanishFrames(drawable.imageData!, vanishOptions.frames, drawable.color)\r\n        }\r\n      } else if (state == DrawState.AnimationFinished) {\r\n        if(vanishOptions.callback && mode == DrawMode.Vanishing) {\r\n          drawable.color = vanishOptions.nextColor!\r\n          drawable.loadImageData()\r\n          this.reloadFrames()\r\n          this.setMode(DrawMode.Unvanishing)\r\n        } else if (mode == DrawMode.Unvanishing) {\r\n          this.setState(DrawState.Normal)\r\n        }\r\n      }\r\n    },\r\n    reloadFrames: function() {\r\n      animationFrames = loadVanishFrames(drawable.imageData!, vanishOptions.frames, drawable.color)\r\n    },\r\n    draw: function(ctx: CanvasRenderingContext2D, delta: number) {\r\n      if(state == DrawState.Normal) {\r\n        normalDraw(ctx, delta)\r\n      } else if(state == DrawState.Animating) {\r\n        animationDuration += delta\r\n        if(animationDuration >= (animationFrames.length * vanishOptions.frameDelay) + vanishOptions.vanishLength) {\r\n          this.setState(DrawState.AnimationFinished)\r\n          return\r\n        }\r\n        let dx = drawable.position.x\r\n        let dy = drawable.position.y\r\n        if(isCircle(drawable)) {\r\n          const radius = drawable.radius\r\n          dx -= radius\r\n          dy -= radius\r\n        }\r\n\r\n        for(let i = 0; i < animationFrames.length; i++) {\r\n          const step = animationDuration - (i+1) * vanishOptions.frameDelay\r\n          let alpha = clamp(1 - (step / vanishOptions.vanishLength), 0, 1)\r\n          if(mode == DrawMode.Unvanishing) {\r\n            alpha = 1 - alpha\r\n          }\r\n          ctx.globalAlpha = alpha\r\n          ctx.drawImage(animationFrames[i], dx, dy)\r\n        }\r\n        ctx.globalAlpha = 1;\r\n      }\r\n    } \r\n  }\r\n\r\n  return Object.assign({}, drawable, vanishable)\r\n}\r\n\r\nconst weightedRandomDistrib = (peak: number, count: number) => {\r\n  const prob = [], seq = [];\r\n  for(let i=0;i<count;i++) {\r\n    prob.push(Math.pow(count-Math.abs(peak-i), count/2));\r\n    seq.push(i);\r\n  }\r\n  return chance.weighted(seq, prob);\r\n}\r\n\r\nfunction loadVanishFrames (imageData: ImageData, count: number, colorFilter?: Color): HTMLImageElement[] {\r\n  let imgs: HTMLImageElement[] = [];\r\n  const pixelArr = imageData.data;\r\n  const data = imageData.data.slice(0).fill(0);\r\n  const width = imageData.width\r\n  const height = imageData.height\r\n  let imageDataArray = Array.from({length: count}, e => data.slice(0));\r\n  \r\n  //put pixel info to imageDataArray (Weighted Distributed)\r\n  for (let i = 0; i < pixelArr.length; i+=4) {\r\n    //find the highest probability canvas the pixel should be in\r\n    const p = Math.floor((i/pixelArr.length) * count)\r\n    const a = imageDataArray[weightedRandomDistrib(p, count)]\r\n    \r\n    // assign RGBA values from image to dust canvas\r\n    a[i] = pixelArr[i]\r\n    a[i+1] = pixelArr[i+1]\r\n    a[i+2] = pixelArr[i+2]\r\n    a[i+3] = pixelArr[i+3]\r\n\r\n    if(colorFilter != undefined) {\r\n      const color = hexToRGB(colorFilter)\r\n      if(a[i] !== color.red || a[i+1] !== color.green || a[i+2] !== color.blue) {\r\n        a[i] = 0\r\n        a[i+1] = 0\r\n        a[i+2] = 0\r\n        a[i+3] = 0\r\n      }\r\n    }\r\n  }\r\n  for(let i = 0; i < imageDataArray.length; i++) {\r\n    let img = new Image()\r\n    let tmpCanvas = document.createElement(\"canvas\")\r\n    tmpCanvas.width = width\r\n    tmpCanvas.height = height\r\n    let tmpCtx = tmpCanvas.getContext(\"2d\")!\r\n    tmpCtx.putImageData(new ImageData(imageDataArray[i], width, height), 0, 0)\r\n    img.src = tmpCanvas.toDataURL('image/png')\t\r\n    imgs.push(img)\r\n  }\r\n  return imgs\r\n}\r\n\r\nfunction hexToRGB(hexString: string){\r\n  const hexColorNumber = parseInt(hexString.replace(\"#\", \"0x\"))\r\n  return {\r\n    red: (hexColorNumber >> 16) & 0xFF,\r\n    green: (hexColorNumber >> 8) & 0xFF,  \r\n    blue: hexColorNumber & 0xFF\r\n  }\r\n}","import IAnimationHandler from './IAnimationHandler';\r\nimport { COLORS } from './Colors';\r\nimport { countDownWithWrap } from '../animations/CanvasCountDown';\r\nimport { iCircle, withVanishingState, DrawState, iVanishingOptions, isVanishable, DrawMode } from '../drawable/Drawable';\r\nimport circle from '../drawable/Circle';\r\nimport { clamp, shuffle } from 'lodash';\r\n\r\ninterface IPoint {\r\n  x: number\r\n  y: number\r\n}\r\n\r\n//configuration\r\nconst circleRadius = 60\r\nconst backgroundColor = 'black'\r\n\r\nenum State {\r\n  Initializing,\r\n  Empty, \r\n  Listening,\r\n  Selecting,\r\n  Finished\r\n}\r\n\r\nenum SelectionMode {\r\n  FirstOnly,\r\n  FullOrder,\r\n  Teams\r\n}\r\n\r\ninterface iSimulatedTouch {\r\n  identifier: number\r\n  pageX: number\r\n  pageY: number\r\n}\r\n\r\ninterface iSelectRandomOptions {\r\n  teamCount?: number\r\n}\r\n\r\nclass SelectRandom implements IAnimationHandler {\r\n  touchStart: (te: TouchEvent) => void\r\n  touchMove: (te: TouchEvent) => void\r\n  touchEnd: (te: TouchEvent) => void\r\n  mouseLeft: (me: MouseEvent) => void\r\n  mouseRight: (me: MouseEvent) => void\r\n\r\n  lastFrame: number\r\n  canvas: HTMLCanvasElement | null\r\n  ctx: CanvasRenderingContext2D | null\r\n  width: number\r\n  height: number\r\n\r\n  activeTouches: (iCircle | (withVanishingState & iCircle))[]\r\n  colors: string[]\r\n  offset: IPoint\r\n  _state: State\r\n  enableResetFlag: boolean\r\n  selectionMode: SelectionMode\r\n  teamCount: number\r\n\r\n  countDownToLock: any\r\n  countDownToSelect: any\r\n  selectedIndex: number\r\n\r\n  constructor(mode = SelectionMode.Teams, options?: iSelectRandomOptions) {\r\n    this.lastFrame = 0\r\n    this.touchStart = this.updateTouches\r\n    this.touchMove = this.updateTouches\r\n    this.touchEnd = this.updateTouches\r\n    this.mouseLeft = this.clickAsTouch\r\n    this.mouseRight = this.clickToCancel\r\n\r\n    this._state = State.Initializing\r\n    this.canvas = null\r\n    this.ctx = null\r\n    this.countDownToLock = null\r\n    this.selectedIndex = -1\r\n    this.selectionMode = mode\r\n    this.teamCount = 2\r\n\r\n    this.activeTouches = []\r\n    this.colors = shuffle(COLORS)\r\n    this.offset = { x: 0, y: 0 }\r\n    this.height = this.width = 0\r\n    this.state = State.Empty\r\n    this.enableResetFlag = false\r\n  }\r\n\r\n  get state(): State { return this._state }\r\n  set state(value) {\r\n    if(value === this._state) {\r\n      return\r\n    }\r\n    this._state = value\r\n    if(this._state === State.Empty) {\r\n      this.colors = shuffle(COLORS)\r\n    }\r\n  }\r\n\r\n  setCanvas = (_canvas: HTMLCanvasElement) => {\r\n    this.canvas = _canvas\r\n    this.ctx = this.canvas.getContext('2d')!\r\n    this.onResize()\r\n  }\r\n\r\n  onResize = () => {\r\n    const rect = this.canvas!.getBoundingClientRect()\r\n    this.offset = { x: rect.left, y: rect.top }\r\n    const canvas = this.canvas!\r\n    this.width = canvas.width\r\n    this.height = canvas.height\r\n    this.countDownToLock = countDownWithWrap(canvas, 2000, { color: \"red\", callback: this.lockPlayers, lineWidth: 10 })\r\n    \r\n  }\r\n\r\n  lockPlayers = () => {\r\n    const touches = this.activeTouches.length;\r\n    const callbacks = this.selectionMode === SelectionMode.FirstOnly ?  this.activeTouches.length - 1 : this.activeTouches.length;\r\n    this.countDownToSelect = countDownWithWrap(this.canvas!, clamp((touches - 1) * 400, 1000, 3000), { color: \"yellow\", callback: this.selectRandomPlayer, callbackInterval: callbacks, lineWidth: 10 })\r\n    let vanishOptions: iVanishingOptions = { vanishLength: 1200, frameDelay: 35, callback: this.selectionMode == SelectionMode.Teams }\r\n    let range = shuffle(Array.from(Array(touches).keys()))\r\n    let teams = new Array(this.teamCount)\r\n    let teamMap = new Array(touches)\r\n    for(let i = 0; i < this.teamCount; i ++) {\r\n      teams[i] = []\r\n    }\r\n    if(this.selectionMode === SelectionMode.Teams) {\r\n      for(let i = 0; i < range.length; i++) {\r\n        teams[i % this.teamCount].push(this.activeTouches[range[i]])\r\n        teamMap[range[i]] = teams[i % this.teamCount][0].id\r\n      }\r\n    }\r\n    console.log(teams)\r\n    this.activeTouches = this.activeTouches.map(t => {\r\n      let options= {}\r\n      if(this.selectionMode === SelectionMode.Teams){\r\n        options = Object.assign(options, { nextColor: this.activeTouches[teamMap[t.id!]].color })\r\n      }\r\n      return withVanishingState(t, this.ctx!, Object.assign(options, vanishOptions))\r\n    })\r\n    this.state = State.Selecting\r\n  }\r\n\r\n  selectRandomPlayer = () => {\r\n    const unpickedTouches = (this.activeTouches as (iCircle & withVanishingState)[]).filter(t => t.getState() === DrawState.Normal)\r\n\r\n    const selectedId = unpickedTouches[Math.floor(Math.random() * unpickedTouches.length)].id\r\n    const index = this.activeTouches.findIndex(t => t.id == selectedId)\r\n    let target = this.activeTouches[index] as iCircle & withVanishingState\r\n    target.setState(DrawState.Animating)\r\n    const threshold = this.selectionMode == SelectionMode.FirstOnly ? 2 : 1\r\n\r\n    if(unpickedTouches.length == threshold) {\r\n      this.state = State.Finished\r\n    }\r\n  }\r\n\r\n  copyTouch = (touch: Touch | iSimulatedTouch): iCircle => {\r\n    const id = touch.identifier\r\n    return circle(id, this.colors[id], { x: touch.pageX - this.offset.x, y: touch.pageY - this.offset.y }, circleRadius)\r\n  }\r\n\r\n  updateTouches = (touchEvent: TouchEvent) => {\r\n    if(this.state == State.Empty || this.state == State.Listening) {\r\n      const touches = Array.from(touchEvent.targetTouches)\r\n      if(touches.length != this.activeTouches.length) {\r\n        this.countDownToLock.reset()\r\n      }\r\n      this.activeTouches = touches.map(t => this.copyTouch(t))\r\n      const touchCount = this.activeTouches.length\r\n      if(touchCount <= 1) {\r\n        this.state = State.Empty\r\n      }\r\n      if(touchCount > 1) {\r\n        this.state = State.Listening\r\n      }\r\n    }\r\n    if(this.state == State.Finished) {\r\n      if(touchEvent.targetTouches.length > 0 && this.enableResetFlag) {\r\n        this.state = State.Empty\r\n        this.enableResetFlag = false\r\n      }\r\n      if(touchEvent.targetTouches.length == 0) {\r\n        this.enableResetFlag = true\r\n      }\r\n    }\r\n  }\r\n\r\n  clickAsTouch = (mouseEvent: MouseEvent) => {\r\n    if(this.state == State.Empty || this.state == State.Listening) {\r\n      const identifier = this.activeTouches.length;\r\n      const touch: iSimulatedTouch = { \r\n        identifier,\r\n        pageX: mouseEvent.clientX,\r\n        pageY: mouseEvent.clientY\r\n      }\r\n\r\n      const newTouch = this.copyTouch(touch);\r\n      this.activeTouches = [...this.activeTouches, newTouch]\r\n\r\n      if(this.activeTouches.length > 1 && this.state == State.Empty) {\r\n        this.state = State.Listening\r\n      }\r\n      this.countDownToLock.reset();\r\n    }\r\n\r\n    if(this.state == State.Finished) {\r\n      this.activeTouches = []\r\n      this.state = State.Empty\r\n    }\r\n  }\r\n\r\n  clickToCancel = (mouseEvent: MouseEvent) => {\r\n    mouseEvent.preventDefault();\r\n    if(this.activeTouches.length == 0 || this.state == State.Selecting) {\r\n      return\r\n    }\r\n\r\n    if(this.state == State.Finished) {\r\n      this.activeTouches = []\r\n      this.state = State.Empty\r\n      return\r\n    }\r\n\r\n    this.activeTouches = this.activeTouches.slice(0, -1);\r\n    if(this.activeTouches.length <= 1) {\r\n      this.state = State.Empty\r\n    }\r\n    this.countDownToLock.reset();\r\n  }\r\n\r\n  doFrame = (elapsedTime: number) => {\r\n    const delta = elapsedTime - this.lastFrame\r\n    this.lastFrame = elapsedTime\r\n    window.requestAnimationFrame(this.doFrame)\r\n    \r\n    if(this.ctx == null || this.ctx == undefined) {\r\n      return\r\n    }\r\n    \r\n    const ctx = this.ctx\r\n    ctx.fillStyle = backgroundColor\r\n    ctx.fillRect(0,0, this.width, this.height)\r\n\r\n    if(this.state == State.Empty) {\r\n      this.countDownToLock.reset()\r\n    }\r\n\r\n    if(this.state == State.Listening) {\r\n      this.countDownToLock.draw(delta)\r\n    }\r\n\r\n    if(this.state == State.Selecting) {\r\n      this.countDownToSelect.draw(delta);\r\n    }\r\n\r\n    for(let touch of this.activeTouches) {\r\n      touch.draw(ctx, delta)\r\n    }\r\n  }\r\n}\r\n\r\nexport default SelectRandom;","import { iCircle, iPoint } from \"./Drawable\";\r\n\r\nexport function isCircle(object: any): object is iCircle {\r\n  return 'radius' in object;\r\n}\r\n\r\nexport default function circle(id: number, color: string, pos: iPoint, radius: number): iCircle {\r\n  let imageData: (ImageData | undefined)\r\n  let position = pos\r\n  return ({\r\n    get id() { return id },\r\n    get imageData() { return imageData },\r\n    get position() { return position },\r\n    set position(value) { position = value },\r\n    get radius() { return radius },\r\n    set radius(value) { radius = value },\r\n    get color() { return color },\r\n    set color(value) { color = value },\r\n    loadImageData: () => {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = radius * 2\r\n      canvas.height = radius * 2\r\n      const context = canvas.getContext('2d')!\r\n      context.fillStyle = \"black\"\r\n      context.fillRect(0,0,canvas.width, canvas.height)\r\n      context.fillStyle = color\r\n      context.arc(radius, radius, radius, 0, Math.PI * 2)\r\n      context.fill()\r\n      imageData = context.getImageData(0, 0, radius * 2, radius * 2)\r\n    },\r\n    draw: (ctx, delta) => {\r\n      ctx.beginPath()\r\n      ctx.fillStyle = color\r\n      ctx.arc(position.x, position.y, radius, 0, Math.PI * 2)\r\n      ctx.fill()\r\n      if(imageData == undefined) {\r\n        const canvas = document.createElement('canvas')\r\n        const context = canvas.getContext('2d')!\r\n        canvas.width = radius * 2\r\n        canvas.height = radius * 2\r\n        context.fillStyle = \"black\"\r\n        context.fillRect(0,0,canvas.width, canvas.height)\r\n        context.fillStyle = color\r\n        context.arc(radius, radius, radius, 0, Math.PI * 2)\r\n        context.fill()\r\n        imageData = context.getImageData(0, 0, radius * 2, radius * 2)\r\n      }\r\n    }\r\n  })\r\n}","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Canvas from './canvas/Canvas';\nimport SelectRandom from './canvas/animator/SelectRandom';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Canvas height={400} width={600} animator={ new SelectRandom() } />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}